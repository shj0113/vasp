#!/usr/bin/perl
#testing
#
#Cartesian basis*coords Correction Needed!!!
#
if(@ARGV<2){die "usage: <filename> <x> <y> <z> | at least 2 argument is needed. \ndefault value:  <filename = POSCAR> <z=1>\n the code is stopped"}
@tmp=@ARGV;
$A{2}=1;
if ($tmp[0]=~/^\w/){$filename=$tmp[0];$A{0}=$tmp[1];$A{1}=$tmp[2];$A{2}=$tmp[3] if @tmp==4;}
if($tmp[0]=~/^\d/){$filename=POSCAR;$A{0}=$tmp[0];$A{1}=$tmp[1];$A{2}=$tmp[2] if @tmp==3;}

#print "$filename, $A{0}, $A{1}, $A{2} \n";

use Math::Trig;
#print $filename;
($coordinates,$basis,$lattice,$num_atoms,$total_atoms,$selectiveflag,$selective,$description,$filetype,$el_atoms,$coords_kar)=read_poscar($filename);
#if($coords_kar==0)
#print "@el_atoms\n";
#print "$el_atoms[0] $el_atoms[1] $el_atoms[2]\n";
write_poscar($coordinates,$basis,$lattice,$num_atoms,$total_atoms,$selectiveflag,$selective,$description,$filetype,$el_atoms);
#}
#else{
#
#	   print STDOUT $description. "\n";
#		for ($i=0; $i<3; $i++) {
#        	for ($j=0; $j<3; $j++) {
#            	printf STDOUT "%21.16f", ($A{$i}*$basis->[$j][$i]/$lattice)." ";
#        	}
#        	print STDOUT "\n";
#    	}
#    	# this right now sets default as vasp5 file type 
#    	#if ($filetype eq "vasp5") {
#    	if ($filetype ne "vasp4") {
#    	    for($i=0; $i<@{$el_atoms}; $i++) {
#				print STDOUT $el_atoms->[$i]."  ";
#			}
#			print STDOUT "\n";
#    		}
#    	for ($i=0; $i<@{$num_atoms}; $i++) {
#	        print STDOUT $num_atoms->[$i]*$A{0}*$A{1}*$A{2} ."  ";
#    		}
#    	print STDOUT "\n";
#
#    if ($selectiveflag =~ /selective/i) { 
#        print STDOUT $selectiveflag."\n";
#    }
#    print STDOUT "Cartesian\n";
#	#pbc condition
#	for ($i=0; $i<$total_atoms; $i++) {
#        for ($j=0; $j<3; $j++) {
#            if ($coordinates->[$i][$j] >1) {$coordinates->[$i][$j] -=1;}
#			elsif($coordinates->[$i][$j] <0) {$coordinates->[$i][$j] +=1;}
#    }
#	}
#
#	$coordinates = dirkar($coordinates,$basis,$lattice,$total_atoms);
#	for($B{0}=0;$B{0}<$A{0};$B{0}++){
#		for($B{1}=0;$B{1}<$A{1};$B{1}++){
#			for($B{2}=0;$B{2}<$A{2};$B{2}++){
#    for ($i=0; $i<$total_atoms; $i++) {
#        for ($j=0; $j<3; $j++) {
#            #$coord = $coordinates->[$i][$j];
#			#
#			$coord[$j]=$coordinates->[$i][$j];
#		}
#		#for($k=0;$k<3;$k++){
#		#$coords[0] += $coord[$k]+$B{0}*($basis->[0][$k])/$lattice;
#		#$coords[1] += $coord[$k]+$B{1}*($basis->[1][$k])/$lattice;
#		#$coords[2] += $coord[$k]+$B{2}*($basis->[2][$k])/$lattice;
#		#}
#		#
#				$coords[0]=$coord[0]+
#				$coords->[0] = $coord->[0]+$B{0}*$basis->[0][0]/$lattice+$coord->[1]+$B{0}*$basis->[0][1]/$lattice+$coord->[2]+$B{0}*$basis->[0][2]/$lattice;
#				$coords->[1] = $coord->[0]+$B{1}*$basis->[1][0]/$lattice+$coord->[1]+$B{1}*$basis->[1][1]/$lattice+$coord->[2]+$B{1}*$basis->[1][2]/$lattice;
#				$coords->[2] = $coord->[0]+$B{2}*$basis->[2][0]/$lattice+$coord->[1]+$B{2}*$basis->[2][1]/$lattice+$coord->[2]+$B{2}*$basis->[2][2]/$lattice;
#			#
#			#$coord = ($coord+$B{$j}*$basis->[$j][$j]/$lattice);
#			#
#            #printf STDOUT "%20.16f", $coord."   "; }
#		printf STDOUT "%20.16f  %20.16f  %20.16f  ", $coords[0], $coords[1], $coords[2];
#        print STDOUT " ".$selective->[$i]."\n";
#    }
#}}}
#	$coordinates = dirkar($coordinates,$basis,$lattice,$total_atoms);
#}









#----------------------------------------------------------------------
# subroutine read_poscar
#     This routine reads in a POSCAR file.
#
#     INPUT: $filename: name of POSCAR file to read
#
#     STDOUTPUT: $coordinates: reference to Nx3 array of coordinates of
#                           POSCAR
#             $basis: reference to 3x3 array of basis vectors
#             $lattice: lattice constant of POSCAR
#             $num_atoms: reference to Mx1 array of number atoms/component
#             $total_atoms: N
#             $selectiveflag: is selective dynamics turned on?
#             $selective: flags for selective dynamics for each atom 
#                         (reference to Nx1 array)
#----------------------------------------------------------------------

sub read_poscar {
    my $filename = shift;
    my $description = "";
    my @poscar = ();
    my $lattice = 1.0;
    my $basis;
    my $num_atoms;
    my $total_atoms = 0;
    my $coordinates;
    my $selectiveflag = "";
    my $atomtypeflag = "";
    my $selective;
    my $filetype;
    my $num_atoms_ = "";
    my @num_atoms = ();
    my $line = "";
    my @line = ();
    my $i = 0;
    my $j = 0;
    my $index;
    my $coords_kar=0;
	my $el_atoms_;
	my $el_atoms;

    open (IN,$filename) or die "cannot open $filename\n"; 		#opening file
    @poscar = <IN>;
    close (IN);

    chop($description = $poscar[0]);
    chop($lattice = $poscar[1]);

    $line = $poscar[5];
    $line =~ s/^\s+//;
    @line = split(/\s+/,$line);
#   if ($line =~ /^s/i) {
    if ($line[0] =~ /^\d+$/) {		#if it starts with number
        $filetype = "vasp4";
        $index = 5;
    } else {
        $filetype = "vasp5";
        $atomtypeflag = 1;
#        chop($description = $poscar[5]); #system description = atomic name
        $index = 6;
    	chop($el_atoms_ = $poscar[5]);
    	$el_atoms_ =~ s/^\s+//;
    	@el_atoms = split(/\s+/,$el_atoms_);
		for($i=0; $i<@el_atoms; $i++) {
			$el_atoms->[$i] = $el_atoms[$i];
		}
    }
    $description =~ s/^\s+//;

    $num_atoms_ = $poscar[$index];
    $num_atoms_ =~ s/^\s+//;
    @num_atoms = split(/\s+/,$num_atoms_);
    for ($i=0; $i<@num_atoms; $i++) {
        $num_atoms->[$i] = $num_atoms[$i];
        $total_atoms += $num_atoms[$i];
    }

    for ($i=0; $i<3; $i++) {
        $line = $poscar[$i+2];
        $line =~ s/^\s+//;
        @line = split(/\s+/,$line);
        # This is how Vasp reads in the basis
        for ($j=0; $j<3; $j++) {
            $basis->[$j][$i] = $line[$j]*$lattice;
        }
    }

    $index += 1;

    $line = $poscar[$index];
    $line =~ s/^\s+//;
    if ($line =~ /^s/i) {
        chop($selectiveflag = $line);
        $index += 2;
    } else { $index += 1; }

    for ($i=$index; $i<$index+$total_atoms; $i++) {
        $poscar[$i] =~ s/^\s+//;
        @line = split(/\s+/,$poscar[$i]);
        for ($j=0; $j<3; $j++) {
            $coordinates->[$i-$index][$j] = $line[$j]; }
        if ($selectiveflag=~/selective/i) {
            $selective->[$i-$index] = $line[3]." ".$line[4]." ".$line[5];
        } else {
            $selective->[$i-$index] = " "; }
    }

    if ($poscar[$index-1] =~ /^c/i) {
		$coords_kar=1;
        for ($i=0; $i<$total_atoms; $i++) {
            for ($j=0; $j<3; $j++) {
                $coordinates->[$i][$j] *= $lattice;
            }
        }
        $coordinates = kardir($coordinates,$basis,$lattice,$total_atoms);
    }
    #$basis=rotate_basis($basis);  # this ensures that there is a smooth conversion back from con format
    return($coordinates,$basis,$lattice,$num_atoms,$total_atoms,$selectiveflag,$selective,$description,$filetype,$el_atoms,$coords_kar);
#print "poscar readed\n"
}

#----------------------------------------------------------------------
# subroutine write_poscar
#     This routine writes out the POSCAR file in direct coordinates
#       
#     INPUT: $coordinates:  reference to Nx3 array
#            $basis: reference to 3x3 array containing basis vectors
#            $lattice:  lattice constant of POSCAR
#            $num_atoms: reference to Mx1 array containing number of
#                        each component of atoms
#            $total_atoms: N
#            $selectiveflag: flag saying if selective dynamics were
#                            used for this POSCAR
#            $selective: reference to Nx1 array containing selective
#                        dynamics flags for each atom
#
#     STDOUTPUT: none
#----------------------------------------------------------------------

sub write_poscar {
    my $coordinates = shift;
    my $basis = shift;
    my $lattice = shift;
    my $num_atoms = shift;
    my $total_atoms = shift;
    my $selectiveflag = shift;
    my $selective = shift;
    my $description = shift;
    my $filetype = shift;
	my @el_atoms = shift;
    my $i = 0;
    my $j = 0;
    my $coord;

#    print "@el_atoms\n";
	print STDOUT $description."-".$A{0}."-".$A{1}."-".$A{2}."\n";
    print STDOUT $lattice."\n";
    for ($i=0; $i<3; $i++) {
        for ($j=0; $j<3; $j++) {
            printf STDOUT "%21.16f", ($A{$i}*($basis->[$j][$i])/$lattice)." "; }
        print STDOUT "\n";
    }
    # this right now sets default as vasp5 file type 
    #if ($filetype eq "vasp5") {
    if ($filetype ne "vasp4") {
    	#print "$el_atoms\n"; 
		for($i=0; $i<@{$el_atoms}; $i++) {
				print STDOUT $el_atoms->[$i]."  ";
			}
			print STDOUT "\n";
    }
    for ($i=0; $i<@{$num_atoms}; $i++) {
        print STDOUT $num_atoms->[$i]*$A{0}*$A{1}*$A{2} ."  ";
    }
    print STDOUT "\n";

    if ($selectiveflag =~ /selective/i) { 
        print STDOUT $selectiveflag."\n";
    }
    print STDOUT "Direct\n";

	for($B{0}=0;$B{0}<$A{0};$B{0}++){
		for($B{1}=0;$B{1}<$A{1};$B{1}++){
			for($B{2}=0;$B{2}<$A{2};$B{2}++){

#				for ($i=0; $i<$total_atoms; $i++) {
				for($i=0;$i<$num_atoms->[0];$i++){
					for ($j=0; $j<3; $j++) {
           				 $coord = $coordinates->[$i][$j];
			            if ($coord>1) { $coord -= 1; }
           			 elsif ($coord<0) { $coord += 1; }
					 $coord=($coord+$B{$j})/$A{$j};
           			 printf STDOUT "%20.16f", $coord."   "; }
			        print STDOUT " ".$selective->[$i]."\n";

			}
		}
	}
	}
	for($B{0}=0;$B{0}<$A{0};$B{0}++){
		for($B{1}=0;$B{1}<$A{1};$B{1}++){
			for($B{2}=0;$B{2}<$A{2};$B{2}++){

#				for ($i=0; $i<$total_atoms; $i++) {
				for($i=$num_atoms->[0];$i<$num_atoms->[0]+$num_atoms->[1];$i++){
					for ($j=0; $j<3; $j++) {
           				 $coord = $coordinates->[$i][$j];
			            if ($coord>1) { $coord -= 1; }
           			 elsif ($coord<0) { $coord += 1; }
					 $coord=($coord+$B{$j})/$A{$j};
           			 printf STDOUT "%20.16f", $coord."   "; }
			        print STDOUT " ".$selective->[$i]."\n";

    }
			}
		}
	}

	for($B{0}=0;$B{0}<$A{0};$B{0}++){
		for($B{1}=0;$B{1}<$A{1};$B{1}++){
			for($B{2}=0;$B{2}<$A{2};$B{2}++){

#				for ($i=0; $i<$total_atoms; $i++) {
				for($i=$num_atoms->[0]+$num_atoms->[1];$i<$num_atoms->[0]+$num_atoms->[1]+$num_atoms->[2];$i++){
			#		print"i=$i";
					for ($j=0; $j<3; $j++) {
           				 $coord = $coordinates->[$i][$j];
			            if ($coord>1) { $coord -= 1; }
           			 elsif ($coord<0) { $coord += 1; }
					 $coord=($coord+$B{$j})/$A{$j};
           			 printf STDOUT "%20.16f", $coord."   "; }
			        print STDOUT " ".$selective->[$i]."\n";

			}
		}
	}
	}

for($B{0}=0;$B{0}<$A{0};$B{0}++){
		for($B{1}=0;$B{1}<$A{1};$B{1}++){
			for($B{2}=0;$B{2}<$A{2};$B{2}++){

#				for ($i=0; $i<$total_atoms; $i++) {
				for($i=$num_atoms->[0]+$num_atoms->[1]+$num_atoms->[2];$i<$num_atoms->[0]+$num_atoms->[1]+$num_atoms->[2]+$num_atoms->[3];$i++){
			#		print"i=$i";
					for ($j=0; $j<3; $j++) {
           				 $coord = $coordinates->[$i][$j];
			            if ($coord>1) { $coord -= 1; }
           			 elsif ($coord<0) { $coord += 1; }
					 $coord=($coord+$B{$j})/$A{$j};
           			 printf STDOUT "%20.16f", $coord."   "; }
			        print STDOUT " ".$selective->[$i]."\n";

			}
		}
	}
	}

for($B{0}=0;$B{0}<$A{0};$B{0}++){
		for($B{1}=0;$B{1}<$A{1};$B{1}++){
			for($B{2}=0;$B{2}<$A{2};$B{2}++){

#				for ($i=0; $i<$total_atoms; $i++) {
				for($i=$num_atoms->[0]+$num_atoms->[1]+$num_atoms->[2]+$num_atoms->[3];$i<$num_atoms->[0]+$num_atoms->[1]+$num_atoms->[2]+$num_atoms->[3]+$num_atoms->[4];$i++){
			#		print"i=$i";
					for ($j=0; $j<3; $j++) {
           				 $coord = $coordinates->[$i][$j];
			            if ($coord>1) { $coord -= 1; }
           			 elsif ($coord<0) { $coord += 1; }
					 $coord=($coord+$B{$j})/$A{$j};
           			 printf STDOUT "%20.16f", $coord."   "; }
			        print STDOUT " ".$selective->[$i]."\n";

			}
		}
	}
	}



#	my @sum_atoms;
#	$sum_atoms[0]=$num_atoms->[0]
#	for($i=0;$i<@{$num_atoms};$i++){
#		$sum_atoms[$
#
#	for($B{0}=0;$B{0}<$A{0};$B{0}++){
#		for($B{1}=0;$B{1}<$A{1};$B{1}++){
#			for($B{2}=0;$B{2}<$A{2};$B{2}++){

#				for ($i=0; $i<$total_atoms; $i++) {
#				for($k=0; $k<@{$num_atoms}; $k++){
#					print "k=$k, num[k]=$num_atoms->[$k]\n";
#				for($i=$num_atoms->[$k]; $i<$num_atoms->[$k+1];$i++){
#					print"#i=$i";
#					for ($j=0; $j<3; $j++) {
#           				 $coord = $coordinates->[$i][$j];
#			            if ($coord>1) { $coord -= 1; }
#           			 elsif ($coord<0) { $coord += 1; }
#					 $coord=($coord+$B{$j})/$A{$j};
#           			 printf STDOUT "%20.16f", $coord."   "; }
#			        print STDOUT " ".$selective->[$i]."\n";
#
#    }
#			}
#		}
#	}
#	}
    return();
}
